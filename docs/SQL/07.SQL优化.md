---
title: SQL语句优化
date: '2019-10-03 08:00:00'
sidebar: 'auto'
categories:
 - SQL
tags:
 - SQL
publish: true
---
[toc]
## 慢查询优化思路
1. 检查表结构关系，查询是否绕弯路
2. 检查是否使用索引
3. 检查是否利用了最优索引
4. 是否查询了多余字段
5. 表中数据是否过多，需不需要分表
6. 机器性能低

## 索引不生效的情况
1. 使用不等于查询，<>,!=,not
2. 在索引列上使用 IS NULL 或 IS NOT NULL操作，索引是不索引空值的，所以这样的操作不能使用索引
3. 列参与了数学运算或者函数
4. 在字符串like时左边是通配符.比如 %xxx
5. 当mysql分析全表扫描比使用索引快的时候不使用索引.
6. 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.
7. or语句前后没有同时使用索引。

## 建立索引
1. 索引中的数据尽可能的少
2. 频繁增删改的列不建立索引
3. 有大量重复值，频繁`BETWEEN`、`ORDER`的列，建立索引
4. 表上的索引过多，影响性能

## 优化索引的使用
1. 尽量使用主键查询。MySql为表建立主键的聚簇索引，主键查询不会回表查询
2. 不做列运算
3. 查询语句尽可能简单，大句拆小句
4. 尽量用`UNION`代替`OR`
5. 在`WHERE`中不适用触发器和函数
6. 不要左匹配通配符，避免`%xxx`,可以使用`REVERSE()`改成`%xxx`
7. 少用`JOIN`
8. 使用同类型的值比较
9. 尽量避免在`WHERE`中使用`!=`或`<>`,否则查询会放弃索引
10. 使用分页，且每页的数据也不要太大
11. 避免在索引上使用`IS NULL`和`IS NOT NULL`

## 表结构优化
1. 尽量使用小的数据类型
2. 尽量使用`TINYINT`,`SMALLINT`,`MEDIUMINT`代替INT
3. 尽量使用`NOT NULL`字段，`NULL`字段会占据4字节
4. 尽量少用`TXT`，非用不可是单独建立一张表
5. 尽量使用`TIMESTAMP`代替`DATETIME`
6. 单表不要太多字段

## 主键优化
>*InnoDB中表数据按照主键顺序存放*

1. 尽量降低主键长度，减少非聚簇索引的空间
2. 按主键顺序插入，尽量选择自增主键
3. 尽量不要使用UUID或其他自然主键(身份证)，无序主键影响性能
4. 避免修改主键

## SELECT优化
1. 避免`SELECT *`
2. [小表驱动大表](01.SQL优化——小表驱动大表.md)
3. 尽量使用`JOIN`代替子查询

## INSERT优化
1. 多使用批量插入
2. 手动提交事务
3. 按主键顺序插入
4. 大批量插入数据时，使用`load`

## ORDER BY优化
>* Using FileSort：通过表的索引或者全表扫描，读取满足条件的行，在缓冲区中排序
>* Using Index： 有序索引顺序扫描返回数据
1. 尽量使用覆盖索引，SELECT *会回表查询对应行数据，为`Using FileSort`
2. 建立合适的索引，多字段索引遵循[最左前缀法则](02.官方文档解释MySQL最左匹配(最左前缀)原则.md)
3. 多字段排序，升降序不统一时，在建立联合索引时就要创建`ASC`/`DESC`规则
4. 必须`Using FileSort`时，适当增加缓冲区大小(默认256K)

## GROUP BY优化
1. 先过滤再分组
2. 分组时可以通过索引提高效率
3. 分组时索引的使用也要满足[最左前缀法则](02.官方文档解释MySQL最左匹配(最左前缀)原则.md)

## LIMIT分页优化
>```sql
>LIMIT 起始行,行数
>```
1. 起始行越大，性能越慢
2. 一般分页查询时，先创建覆盖索引，在连表查询
> 优化前：
> ```sql
>select * from t_trade_order
>where create_time
>between '2019-10-17' and '2019-10-25'
>limit 1000000, 10; --(create_time建表时被设置为普通索引)
>```
   >1. 在create_time索引树上找到create_time=‘2019-10-17’的记录，取得其id。
   >2. 再到主索引树查到对于id的记录
   >3. 更新时间，循环步骤1、2
   >4. ...
   >5. 在create_time索引树取下一个值create_time='2019-10-25'，不满足条件，循环结束。
   >6. 查询结果放弃前1000000行，返回10行  

*显然，普通的分页查询是逐一通过普通索引获得id然后回表查询，每次回表进行一次IO，造成相当大的性能浪费。*

>优化后:
>```sql
>select * from t_trade_order t
>inner join (
>select id from t_trade_order
>where create_time between '2019-10-17' and'2019-10-25'
>limit 1000000, 10) e
>on t.id = e.id;
>```
   >1. 使用覆盖索引`select id from t_trade_order where create_time between '2019-10-17' and '2019-10-25' limit 1000000, 10`查询结果放弃前1000000行，返回10行，查询出符合查询范围的`id`
   >2. 回表关联，根据获得的id关联主索引表，批量匹配得到结果。(只需回到主索引表一次)

*由此可知，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行，这可以减少MySQL回表的次数，也避免了MySQL直接在原表上扫描那些需要丢弃的行数（实则在普通索引树上扫描，速度快很多）。*

## 其他
1. 使用`UPDATE`时，尽量根据主键或索引更新
2. DISTINCT的字段要少，避免`DISTINCT *`
3. 不要超过5个以上的`JOIN`
4. [`COUNT`性能比较](03.COUNT()和COUNT(1)有什么区别.md)      
